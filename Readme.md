# Chit - Channel-based generic iterators

[![Tests](https://github.com/bobg/chit/actions/workflows/go.yml/badge.svg)](https://github.com/bobg/chit/actions/workflows/go.yml)

This is chit,
an implementation of channel-based generic iterators for Go 1.18 and later.

These iterators are implemented in terms of channels and goroutines,
details that are mostly invisible to the caller.
This is as opposed to
(what might at first seem to be)
the more obvious approach:
defining an abstract iterator interface,
then writing a bunch of concrete types implementing that interface.

The abstract-iterator approach is fine for things like a filter:

```go
type Iter[T any] interface {
	Next() (T, bool)
}

type FilterIter[T any] struct {
	inp Iter[T]
	f   func(T) bool
}

func (f *FilterIter[T]) Next() (T, bool) {
	for {
		x, ok := f.inp.Next()
		if !ok {
			return x, false
		}
		if f(x) {
			return x, true
		}
	}
}
```

but less-trivial iterators quickly run into concurrency issues,
code repetition,
and complexity arising from splitting state information between the concrete data structure and the `Next` function.

All of this is improved with a channel-and-goroutine-based approach,
at the cost of some performance.
Channels are concurrency-safe;
and with a single callback function
(running in a goroutine)
producing all of an iteratorâ€™s elements,
there is no need to store intermediate state in a data object.

Here is the output of `go doc -all .`
(until pkg.go.dev is able to format Godoc for 1.18 code).

```
package chit // import "github.com/bobg/chit"

Chit defines functions for operating on channels as generic iterators.

FUNCTIONS

func ToMap[K comparable, V any](ctx context.Context, inp *Iter[Pair[K, V]]) (map[K]V, error)
    ToMap consumes all the elements of an iterator over key-value pairs and
    returns them as a map. All but the last of any pairs with duplicate keys are
    overwritten.

func ToSlice[T any](ctx context.Context, inp *Iter[T]) ([]T, error)
    ToSlice consumes all of an iterator's elements and returns them as a slice.
    Be sure your input isn't infinite, or very large! (Consider using FirstN to
    ensure the input has a reasonable size.)


TYPES

type Iter[T any] struct {
	// Err contains any error that might have closed the channel prematurely.
	// Callers should read it only after a call to Iter.Next returns a false "ok" value.
	Err error

	// Has unexported fields.
}
    Iter[T] is an iterator over items of type T. It contains an underlying
    channel of type <-chan T. Create an Iter[T] with New[T].

func Accum[T any](ctx context.Context, inp *Iter[T], f func(T, T) (T, error)) *Iter[T]
    Accum accumulates the result of repeatedly applying a function to the
    elements of an iterator. If inp[i] is the ith element of the input and
    out[i] is the ith element of the output, then:

        out[0] == inp[0]

    and

        out[i+1] == f(out[i], inp[i+1])

func Concat[T any](ctx context.Context, inps ...*Iter[T]) *Iter[T]
    Concat[T] takes a sequence of iterators and produces an iterator over all
    the elements of the input iterators, in sequence.

func Dup[T any](ctx context.Context, inp *Iter[T], n int) []*Iter[T]
    Dup[T] duplicates the contents of an iterator, producing n new iterators,
    each containing the members of the original.

    An internal buffer grows to roughly the size of the difference between the
    output iterator that is farthest ahead in the stream, and the one that is
    farthest behind.

func Filter[T any](ctx context.Context, inp *Iter[T], f func(T) (bool, error)) *Iter[T]
    Filter filters the elements of an iterator according to a predicate
    function. Only the elements in the input iterator producing a true value
    appear in the output iterator.

func FirstN[T any](ctx context.Context, inp *Iter[T], n int) *Iter[T]
    FirstN produces an iterator containing the first n elements of the input (or
    all of the input, if there are fewer than n elements). Excess elements in
    the input are discarded by calling inp.Cancel.

func FromMap[K comparable, V any](ctx context.Context, inp map[K]V) *Iter[Pair[K, V]]
    FromMap creates a channel iterator over a map.

func FromSlice[T any](ctx context.Context, inp []T) *Iter[T]
    FromSlice creates a channel iterator over a slice.

func Gen[T any](ctx context.Context, f func() (T, bool, error)) *Iter[T]
    Gen produces an iterator whose members are generated by successive calls to
    a given function.

func Ints(ctx context.Context, start, delta int) *Iter[int]
    Ints produces an infinite iterator of integers, starting at start and
    incrementing by delta.

func LastN[T any](ctx context.Context, inp *Iter[T], n int) *Iter[T]
    LastN produces an iterator containing the last n elements of the input (or
    all of the input, if there are fewer than n elements). This requires
    buffering up to n elements. There is no guarantee that any elements will
    ever be produced: the input iterator may be infinite!

func Map[T, U any](ctx context.Context, inp *Iter[T], f func(T) (U, error)) *Iter[U]
    Map transforms a sequence of T-type elements into a sequence of U-type
    elements by applying a function to each one.

func New[T any](ctx context.Context, writer func(send func(T) error) error) *Iter[T]
    New[T] creates a new Iter[T].

    The writer function is invoked once (in a goroutine), and must supply all of
    the iterator's elements by repeated calls to the send function (which,
    buffering aside, will block until a downstream reader requires the value
    being sent). If the send function returns an error, the writer function
    should return early with that error.

    Any error returned by the writer function will be placed in the Err field of
    the resulting iterator.

func Repeat[T any](ctx context.Context, val T) *Iter[T]
    Repeat produces an infinite iterator of the given element, over and over.
    Useful in combination with FirstN when you want a certain number of the same
    item.

func SQL[T any](ctx context.Context, db QueryerContext, query string, args ...any) *Iter[T]
    SQL[T] performs a query against db and returns the results as an iterator of
    type T. T must be a struct type whose fields have the same types, in the
    same order, as the values being queried. The values produced by the iterator
    will be instances of that struct type, with fields populated by the queried
    values.

func SkipN[T any](ctx context.Context, inp *Iter[T], n int) *Iter[T]
    SkipN produces an iterator containing all but the first n elements of the
    input. If the input contains n or fewer elements, the output iterator will
    be empty.

func SkipUntil[T any](ctx context.Context, inp *Iter[T], f func(T) (bool, error)) *Iter[T]
    SkipUntil skips the inital elements of the input until calling the given
    predicate on an element returns true; then it copies that and the remaining
    elements to the output. The predicate is not called again after the first
    time it returns true.

func Zip[T, U any](ctx context.Context, t *Iter[T], u *Iter[U]) *Iter[Pair[T, U]]
    Zip takes two iterators and produces a new iterator containing pairs of
    corresponding elements. If one input iterator ends before the other, Zip
    produces zero values of the appropriate type in constructing pairs.

func (it *Iter[T]) Cancel()
    Cancel cancels the context in the iterator. This normally causes the
    iterator's "writer" function to terminate early, closing the iterator's
    underlying channel and causing Next calls to return context.Canceled.

func (it *Iter[T]) Next() (T, bool, error)
    Next reads the next item from the iterator.

type Pair[T, U any] struct {
	X T
	Y U
}
    Pair is a simple generic pair struct.

type QueryerContext interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
}
    QueryerContext is a minimal interface satisfied by *sql.DB (from
    database/sql).
```
