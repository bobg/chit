# Chit - Channel-based generic iterators

[![Go Reference](https://pkg.go.dev/badge/github.com/bobg/chit.svg)](https://pkg.go.dev/github.com/bobg/chit)
[![Go Report Card](https://goreportcard.com/badge/github.com/bobg/chit)](https://goreportcard.com/report/github.com/bobg/chit)
[![Tests](https://github.com/bobg/chit/actions/workflows/go.yml/badge.svg)](https://github.com/bobg/chit/actions/workflows/go.yml)
[![Coverage Status](https://coveralls.io/repos/github/bobg/chit/badge.svg?branch=master)](https://coveralls.io/github/bobg/chit?branch=master)

This is chit,
an implementation of channel-based generic iterators for Go 1.18 and later.

Here is the output of `go doc -all .`
(until pkg.go.dev is able to format Godoc for 1.18 code).

```
package chit // import "github.com/bobg/chit"

Chit defines functions for operating on channels as generic iterators.

FUNCTIONS

func ToSlice[T any](ctx context.Context, inp *Iter[T]) ([]T, error)
    ToSlice consumes all of an iterator's elements and returns them as a slice.
    Be sure your input isn't infinite, or very large! (Consider using FirstN to
    limit


TYPES

type Iter[T any] struct {
	// Err contains any error that might have closed the channel prematurely.
	// Callers should read it only after a call to Iter.Read returns a false "ok" value.
	Err error

	// Has unexported fields.
}
    Iter[T] is an iterator over items of type T. It contains an underlying
    channel of type <-chan T. Create an Iter[T] with New[T].

func Accum[T any](ctx context.Context, inp *Iter[T], f func(T, T) (T, error)) *Iter[T]
    Accum accumulates the result of repeatedly applying a function to the
    elements of an iterator. If inp[i] is the ith element of the input and
    out[i] is the ith element of the output, then out[0] == inp[0], and out[i+1]
    = f(out[i], inp[i+1])

func Concat[T any](ctx context.Context, inps ...*Iter[T]) *Iter[T]
    Concat[T] takes a sequence of iterators and produces an iterator over all
    the elements of the input iterators, in sequence.

func Dup[T any](ctx context.Context, inp *Iter[T], n int) []*Iter[T]
    Dup[T] duplicates the contents of an iterator, producing n new iterators,
    each containing the members of the original.

    An internal buffer grows to roughly the size of the difference between the
    output iterator that is farthest ahead in the stream, and the one that is
    farthest behind.

func Filter[T any](ctx context.Context, inp *Iter[T], f func(T) (bool, error)) *Iter[T]
    Filter filters the elements of an iterator according to a predicate
    function. Only the elements in the input iterator producing a true value
    appear in the output iterator.

func FirstN[T any](ctx context.Context, inp *Iter[T], n int) *Iter[T]
    FirstN produces an iterator containing the first n elements of the input (or
    all of the input, if there are fewer than n elements). Excess elements in
    the input are discarded by calling inp.Cancel.

func FromSlice[T any](ctx context.Context, inp []T) *Iter[T]
    FromSlice creates a channel iterator over a slice.

func Gen[T any](ctx context.Context, f func() (T, bool, error)) *Iter[T]
    Gen produces an iterator whose members are generated by successive calls to
    a given function.

func Group[T any, U comparable](ctx context.Context, inp *Iter[T], partition func(T) (U, error)) *Iter[Pair[U, *Iter[T]]]
    Group partitions the elements of an iterator into multiple separate iterator
    streams based on a given partitioning function. Each item in the input is
    fed to the function to see which partition it belongs in. The output is an
    iterator of X,Y pairs where X is the partition key and Y is an iterator over
    the elements in that partition.

    Callers reading the top-level output iterator should launch goroutines to
    consume the nested iterators. Otherwise the process trying to consume items
    in partition P1 is likely to block while the Group iterator waits for
    something to consume an item in partition P2.

    Example:

        var (
          groups = Group(ctx, input, partitionFunc)
          wg     sync.WaitGroup
        )
        for {
          pair, ok, err := groups.Read()
          // ...check err...
          if !ok {
            break
          }
          wg.Add(1)
          go func() {
            defer wg.Done()
            partitionKey, partitionItems := pair.X, pair.Y
            for {
              item, ok, err := partitionItems.Read()
              // ...check err...
              if !ok {
                break
              }
              // ...handle item...
            }
          }()
        }
        wg.Wait()

func Ints(ctx context.Context, start, delta int) *Iter[int]
    Ints produces an infinite iterator of integers, starting and start and
    incrementing by delta.

func LastN[T any](ctx context.Context, inp *Iter[T], n int) *Iter[T]
    LastN produces an iterator containing the last n elements of the input (or
    all of the input, if there are fewer than n elements). This requires
    buffering up to n elements. There is no guarantee that any elements will
    ever be produced: the input iterator may be infinite!

func Map[T, U any](ctx context.Context, inp *Iter[T], f func(T) (U, error)) *Iter[U]
    Map transforms a sequence of T-type elements into a sequence of U-type
    elements by applying a function to each one.

func New[T any](ctx context.Context, writer func(context.Context, chan<- T) error) *Iter[T]
    New[T] creates a new Iter[T]. The writer function is invoked once in a
    goroutine, and must supply all of the iterator's elements on the given
    channel. The writer function must not close the channel; this will happen
    automatically when the function exits.

func Repeat[T any](ctx context.Context, val T) *Iter[T]
    Repeat produces an infinite iterator of the given element, over and over.
    Useful in combination with FirstN when you want a certain number of the same
    item.

func Zip[T, U any](ctx context.Context, t *Iter[T], u *Iter[U]) *Iter[Pair[T, U]]
    Zip takes two iterators and produces a new iterator containing pairs of
    corresponding elements. If one input iterator ends before the other, Zip
    produces zero values of the appropriate type in constructing pairs.

func (it *Iter[T]) Cancel()
    Cancel cancels the context in the iterator. This normally causes the
    iterator's "writer" function to terminate early, closing the iterator's
    underlying channel and causing Read calls to return context.Canceled.

func (it *Iter[T]) Read() (T, bool, error)
    Read reads the next item from the iterator.

type Pair[T, U any] struct {
	X T
	Y U
}
    Pair is a simple generic pair struct.
```
